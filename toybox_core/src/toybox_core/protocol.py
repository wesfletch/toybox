#!/usr/bin/env python3

from dataclasses import dataclass
import socket
import struct
from typing import Any, Tuple, Type

from google.protobuf.message import Message, DecodeError

from toybox_core.Logging import LOG

PREFIX_LENGTH: int = 4
PREFIX_TYPE_LENGTH: int = 2
PREFIX_PAYLOAD_LENGTH: int = 2

@dataclass
class TbxMessage():
    message_raw: bytes
    type_length: int
    payload_length: int
    
def read(
    sock: socket.socket
) -> TbxMessage | None:
    """
    Read a single Toybox-protocol message from the given socket.

    Args:
        sock (socket.socket): Socket to read the message off of

    Raises:
        e: socket.error

    Returns:
        TbxMessage | None: ()
    """

    # attempt to receive first PREFIX_LEGNTH bytes of message
    try:
        prefix_bytes: bytes = sock.recv(PREFIX_LENGTH)
    except socket.error as e:
        raise e

    # unpack (L)ength -> first PREFIX_LENGTH bytes
    prefix: Tuple[Any,...] = struct.unpack("HH", prefix_bytes)
    message_type_len: int = prefix[0]
    message_payload_len: int = prefix[1]
    LOG(log_level="DEBUG", message=f"Reading <{message_type_len + message_payload_len}> \
        bytes, <{message_type_len}> type, <{message_payload_len}> message.")
    
    # receive (T)ype and (V)alue
    received: bytes = sock.recv(message_type_len + message_payload_len)
    LOG(log_level="DEBUG", message=f"Received bytes <{received!r}>")

    return TbxMessage(message_raw=received, 
                      type_length=message_type_len,
                      payload_length=message_payload_len)


def pack_message(
    message: Message,
) -> bytes:
    """
    Package a pb2 object into a `bytes` message ready for socket transmission. 
    Messages are in Length-Type-Value (LTV) format.

    Args:
        message (Message): message (pb2) to package into LTV format
    """

    # pack (T)ype and (V)alue
    LOG(log_level="DEBUG", message=f"packing <{message.DESCRIPTOR.full_name}>")
    message_type: bytes = message.DESCRIPTOR.full_name.encode('utf-8')
    LOG(log_level="DEBUG", message=f"sending message type <{message_type!r}>")
    message_bytes: bytes = message.SerializeToString()
    
    LOG(log_level="DEBUG", message=f"message contents <{message_bytes!r}> == <{message_bytes.hex()}")

    # Prepend messages with (L)ength, 2 bytes for type length, 2 bytes for data length
    # "H" == unsigned short == 2 bytes      
    type_len: bytes = struct.pack("H", len(message_type))
    payload_len: bytes = struct.pack("H", len(message_bytes))
    
    LOG(log_level="DEBUG", message=f"type length == <{type_len!r}> == <{type_len.hex()}>")
    LOG(log_level="DEBUG", message=f"payload length == <{payload_len!r}> == <{payload_len.hex()}>")
    
    # pack bytes
    packed_message: bytearray = bytearray()
    packed_message += type_len
    packed_message += payload_len
    packed_message += message_type
    packed_message += message_bytes

    LOG(log_level="DEBUG", message=f"packed message <{packed_message}> == <{packed_message.hex()}>")
    
    return bytes(packed_message)


def unpack_message(
    obj_type: Type[Message], 
    message_data: bytes
) -> Message:
    """
    Deserialize message data into Message object

    Args:
        obj_type (Type[Message]): the expected Message type of the data
        message_data (bytes): data to be deserialized

    Raises:
        e: DecodeError

    Returns:
        Message: object generated by deserializing `message_data`
    """

    if not isinstance(obj_type, type(Message)):
        raise Exception(f"`obj_type` {obj_type} is not a Message type")

    message: Message = obj_type()
    try:
        message.ParseFromString(message_data)
    except DecodeError as e:
        LOG("ERR", f"We just got garbage: {e}")
        raise e
    
    return message

def split_message(
    message: bytes,
    type_len: int,
    payload_len: int,
) -> Tuple[str, bytes]:
    """
    Assumes that prefix Length bytes have already been removed.

    Args:
        message (bytes): a `bytes` message to be split

    Returns:
        Tuple[bytes, bytes]: (message_type, message_data)
    """

    LOG("DEBUG", f"Message before split <{message!r}>, type_len={type_len}, payload_len={payload_len}")
    message_type: str = message[0:type_len].decode('utf-8')
    LOG("DEBUG", f"Received message type: <{message_type}>")
    message_data: bytes = message[type_len:type_len+payload_len+1]
    LOG("DEBUG", f"Received message data: <{message_data!r}>")

    return (message_type, message_data)
